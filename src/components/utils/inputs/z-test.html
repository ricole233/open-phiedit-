<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Vueç»„ä»¶æµ‹è¯•</title>
    <!-- å¼•å…¥Vue -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #1E1E1E;
            color: #E6E6E6;
        }
        .test-container {
            margin: 20px 0;
            padding: 10px;
            border: 1px solid #4A4A4A;
            background-color: #2D2D2D;
        }
        .vue-input-control {
            background-color: #3A3A3A;
            color: #E6E6E6;
            border: 1px solid #4A4A4A;
            border-radius: 2px;
            padding: 3px;
            margin: 5px;
        }
        
        /* ValueInput ç»„ä»¶æ ·å¼ */
        .value-input-container {
            position: relative;
            display: inline-block;
        }
        
        .value-input-container.disabled {
            opacity: 0.7;
        }
        
        .value-input {
            width: 40px;
            height: 20px;
            background-color: #2c2c2c;
            border: none;
            font-size: 12px;
            text-align: center;
            padding: 0;
            margin: 0;
            color: #ccc;
            outline: none;
            cursor: ew-resize; /* é»˜è®¤æ˜¾ç¤ºåŒå‘ç®­å¤´ */
        }
        
        .value-input.disabled {
            cursor: not-allowed;
            background-color: #252525;
            color: #666;
        }
        
        .value-input:focus {
            background-color: #3a3a3a;
            color: #fff;
            cursor: text; /* ç¼–è¾‘æ—¶æ˜¾ç¤ºæ–‡æœ¬å…‰æ ‡ */
        }
        
        .value-input.dragging {
            cursor: ew-resize;
            user-select: none;
        }
        
        /* æ‹–åŠ¨æ—¶ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
        .value-input-container:active {
            user-select: none;
        }
        
        .drag-indicator {
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border: 1px solid #00a8ff;
            border-radius: 3px;
            pointer-events: none;
            opacity: 0.5;
        }
        
        .drag-indicator.dragging {
            background-color: rgba(0, 168, 255, 0.1);
            opacity: 1;
        }
        
        /* MixNumber ç»„ä»¶æ ·å¼ */
        .mix-number-container {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .separator {
            color: #ccc;
            user-select: none;
        }
        
        /* LockValueInput ç»„ä»¶æ ·å¼ */
        .lock-value-input {
            display: inline-flex;
            align-items: center;
            gap: 2px;
        }
        
        .lock-button {
            width: 20px;
            height: 20px;
            padding: 0;
            background-color: #2c2c2c;
            border: none;
            color: #666;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }
        
        .lock-button.locked {
            color: #00a8ff;
        }
    </style>
</head>
<body>
    <h1>Vueç»„ä»¶æŒ‚è½½æµ‹è¯•</h1>
    <p>è¿™ä¸ªé¡µé¢æµ‹è¯•Vueç»„ä»¶æ˜¯å¦èƒ½æ­£ç¡®æŒ‚è½½å’Œæ¸²æŸ“</p>

    <!-- VueæŒ‚è½½ç‚¹ -->
    <div id="app">
        <h2>åŸºæœ¬ç»„ä»¶æµ‹è¯•</h2>
        <div class="test-container">
            <p>ValueInputç»„ä»¶: {{ testValue }}</p>
            <value-input 
                v-model="testValue"
                :step="0.1"
                :precision="1"
            ></value-input>
            <p><small>æç¤ºï¼šå·¦å³æ‹–åŠ¨å¯è°ƒèŠ‚å€¼ï¼ŒæŒ‰ä½Shifté”®å¤§å¹…åº¦è°ƒæ•´ï¼ŒæŒ‰ä½Ctrlé”®å¾®è°ƒã€‚åŒå‡»å¯è¾“å…¥å€¼ï¼Œæ”¯æŒè¡¨è¾¾å¼è®¡ç®—ã€‚</small></p>
        </div>

        <h2>Mix-Numberç»„ä»¶æµ‹è¯•</h2>
        <div class="test-container">
            <p>MixNumberç»„ä»¶: {{ mixValue }} (å¦‚2.25è¡¨ç¤º2+1/4)</p>
            <mix-number
                v-model="mixValue"
                :denominator="4"
                :denominator-locked="denominatorLocked"
                :denominator-list="[2, 4, 8, 16, 32]"
                @update:denominator-locked="updateDenominatorLocked"
            ></mix-number>
            <p><small>æç¤ºï¼šç¬¬ä¸€ä¸ªè¾“å…¥æ¡†æ˜¯æ•´æ•°éƒ¨åˆ†ï¼Œç¬¬äºŒä¸ªæ˜¯åˆ†å­ï¼Œç¬¬ä¸‰ä¸ªæ˜¯åˆ†æ¯ã€‚ç‚¹å‡»é”æŒ‰é’®å¯é”å®š/è§£é”åˆ†æ¯ã€‚</small></p>
        </div>
    </div>

    <script>
        // åˆ›å»ºVueåº”ç”¨
        const { createApp, ref, defineComponent, watch, computed, nextTick } = Vue;

        // å®šä¹‰ValueInputç»„ä»¶ - ä»çœŸå®ç»„ä»¶ç§»æ¤
        const ValueInput = {
            name: 'ValueInput',
            props: {
                modelValue: {
                    type: [Number, String],
                    default: 0
                },
                min: {
                    type: Number,
                    default: -Infinity
                },
                max: {
                    type: Number,
                    default: Infinity
                },
                step: {
                    type: Number,
                    default: 1
                },
                precision: {
                    type: Number,
                    default: 0
                },
                disabled: {
                    type: Boolean,
                    default: false
                },
                loop: {
                    type: Boolean,
                    default: false
                },
                allowOutOfRange: {
                    type: Boolean,
                    default: false
                },
                allowedValues: {
                    type: Array,
                    default: undefined
                }
            },
            template: `
                <div 
                    class="value-input-container" 
                    @mouseenter="isHovering = true" 
                    @mouseleave="isHovering = false"
                    ref="container"
                    :class="{ 'disabled': disabled }"
                >
                    <input 
                        ref="input"
                        type="text" 
                        class="value-input" 
                        :class="{ 'dragging': isDragging, 'disabled': disabled }"
                        v-model="displayValue"
                        @blur="onBlur"
                        @keydown.enter="onBlur"
                        @mousedown="handleMouseDown"
                        @dblclick="enableEdit"
                        :readonly="!isEditing || disabled"
                        :disabled="disabled"
                    />
                    <div 
                        v-if="(isHovering || isDragging) && !disabled" 
                        class="drag-indicator"
                        :class="{ 'dragging': isDragging }"
                    >
                    </div>
                </div>
            `,
            setup(props, { emit }) {
                // ç»„ä»¶çŠ¶æ€
                const displayValue = ref(formatValue(props.modelValue));
                const isHovering = ref(false);
                const isDragging = ref(false);
                const isEditing = ref(false);
                const startX = ref(0);
                const currentValue = ref(Number(props.modelValue));
                const tempValue = ref(0);
                const currentPlus = ref(0);
                const container = ref(null);
                const input = ref(null);

                const dragSensitivity = {
                    normal: 0.5,
                    shift: 2.0,   // å¤§èŒƒå›´è°ƒæ•´
                    ctrl: 0.1     // ç²¾ç»†è°ƒæ•´
                };

                // ç›‘å¬valueå±æ€§å˜åŒ–
                watch(() => props.modelValue, (newVal) => {
                    if (!isDragging.value && !isEditing.value) {
                        currentValue.value = Number(newVal);
                        displayValue.value = formatValue(newVal);
                    }
                });

                // æ ¼å¼åŒ–å€¼ä¸ºæŒ‡å®šç²¾åº¦çš„å­—ç¬¦ä¸²
                function formatValue(val) {
                    const num = parseFloat(String(val));
                    return isNaN(num) ? '0' : num.toFixed(props.precision);
                }

                // å¤„ç†å€¼çš„èŒƒå›´ï¼Œæ”¯æŒå¾ªç¯æ¨¡å¼å’Œå…è®¸è¶…å‡ºèŒƒå›´æ¨¡å¼
                function handleValueRange(value) {
                    // å¦‚æœæä¾›äº†å…è®¸å€¼åˆ—è¡¨ä¸”ä¸ä¸ºç©ºï¼Œåˆ™ä»åˆ—è¡¨ä¸­é€‰æ‹©æœ€æ¥è¿‘çš„å€¼
                    if (props.allowedValues && props.allowedValues.length > 0) {
                        // å¦‚æœå€¼æ°å¥½åœ¨åˆ—è¡¨ä¸­ï¼Œç›´æ¥è¿”å›
                        if (props.allowedValues.includes(value)) {
                            return value;
                        }
                        
                        // å¦åˆ™æ‰¾åˆ°æœ€æ¥è¿‘çš„å€¼
                        let closestValue = props.allowedValues[0];
                        let minDiff = Math.abs(value - closestValue);
                        
                        for (const allowedValue of props.allowedValues) {
                            const diff = Math.abs(value - allowedValue);
                            if (diff < minDiff) {
                                closestValue = allowedValue;
                                minDiff = diff;
                            }
                        }
                        
                        return closestValue;
                    }
                    
                    if (props.allowOutOfRange) {
                        // å…è®¸è¶…å‡ºèŒƒå›´ï¼Œç›´æ¥è¿”å›å€¼
                        return value;
                    }
                    
                    if (props.loop) {
                        // å¾ªç¯æ¨¡å¼
                        const range = props.max - props.min;
                        const precision = Math.pow(10, -props.precision);
                        const adjustedRange = range + precision;
                        
                        if (value > props.max) {
                            // å‘ä¸Šæº¢å‡º
                            const overflow = value - props.max;
                            const loops = Math.floor(overflow / adjustedRange);
                            const remainder = overflow % adjustedRange;
                            return props.min + remainder;
                        } else if (value < props.min) {
                            // å‘ä¸‹æº¢å‡º
                            const underflow = props.min - value;
                            const loops = Math.floor(underflow / adjustedRange);
                            const remainder = underflow % adjustedRange;
                            return props.max - remainder;
                        }
                    }
                    
                    // é»˜è®¤è¡Œä¸ºï¼šé™åˆ¶åœ¨èŒƒå›´å†…
                    return Math.min(Math.max(value, props.min), props.max);
                }

                // å¤±ç„¦æˆ–å›è½¦æ—¶æäº¤å€¼
                function onBlur() {
                    isEditing.value = false;
                    
                    try {
                        // å°è¯•è®¡ç®—è¡¨è¾¾å¼
                        const expressionValue = evaluateExpression(displayValue.value);
                        const numValue = parseFloat(String(expressionValue));
                        
                        if (isNaN(numValue)) {
                            displayValue.value = formatValue(currentValue.value);
                            return;
                        }
                        
                        const processedValue = handleValueRange(numValue);
                        currentValue.value = processedValue;
                        displayValue.value = formatValue(processedValue);
                        emit('update:modelValue', processedValue);
                    } catch (error) {
                        // è¡¨è¾¾å¼æ— æ•ˆï¼Œä¿æŒåŸæœ‰è¡Œä¸º
                        const numValue = parseFloat(displayValue.value);
                        
                        if (isNaN(numValue)) {
                            displayValue.value = formatValue(currentValue.value);
                            return;
                        }
                        
                        const processedValue = handleValueRange(numValue);
                        currentValue.value = processedValue;
                        displayValue.value = formatValue(processedValue);
                        emit('update:modelValue', processedValue);
                    }
                }

                // å®‰å…¨åœ°è®¡ç®—è¡¨è¾¾å¼
                function evaluateExpression(expression) {
                    // æ¸…ç†è¡¨è¾¾å¼ï¼Œåªä¿ç•™æ•°å­—å’ŒåŸºæœ¬è¿ç®—ç¬¦
                    const cleanExpr = expression.replace(/[^0-9+\-*/().]/g, '');
                    
                    // æ£€æŸ¥è¡¨è¾¾å¼æ˜¯å¦åŒ…å«è¿ç®—ç¬¦
                    if (!/[+\-*/]/.test(cleanExpr)) {
                        return parseFloat(cleanExpr);
                    }
                    
                    // ä½¿ç”¨Functionæ„é€ å‡½æ•°è®¡ç®—è¡¨è¾¾å¼ï¼Œæ¯”evalæ›´å®‰å…¨
                    const result = new Function('return ' + cleanExpr)();
                    return result;
                }

                // å¯ç”¨ç¼–è¾‘æ¨¡å¼
                function enableEdit() {
                    if (props.disabled) return;
                    
                    isEditing.value = true;
                    nextTick(() => {
                        if (input.value) {
                            input.value.focus();
                            input.value.select();
                        }
                    });
                }

                // å¤„ç†é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
                function handleMouseDown(event) {
                    if (props.disabled) return;
                    
                    if (event.detail === 2) {
                        // åŒå‡»äº‹ä»¶ç”±dblclickå¤„ç†
                        return;
                    }
                    
                    // åªæœ‰åœ¨éç¼–è¾‘æ¨¡å¼ä¸‹æ‰å¯åŠ¨æ‹–åŠ¨
                    if (!isEditing.value) {
                        event.preventDefault();
                        startDrag(event);
                    }
                }

                // å¼€å§‹æ‹–æ‹½è°ƒæ•´å€¼
                function startDrag(event) {
                    if (props.disabled) return;
                    
                    isDragging.value = true;
                    startX.value = event.clientX;
                    
                    // è®°å½•å¼€å§‹æ‹–åŠ¨æ—¶çš„å€¼
                    const initialValue = currentValue.value;
                    // é‡ç½®æ•´æ•°è¿›ä½è®¡æ•°å™¨
                    tempValue.value = 0;
                    currentPlus.value = 0;
                    
                    // è·Ÿè¸ªåŸå§‹ç´¯ç§¯å˜åŒ–ï¼ˆä¸å—å¾ªç¯é™åˆ¶å½±å“ï¼‰
                    let rawAccumulatedChange = 0;
                    let previousDeltaX = 0;
                    
                    const handleMouseMove = (e) => {
                        if (!isDragging.value) return;
                        
                        const deltaX = e.clientX - startX.value;
                        const deltaDiff = deltaX - previousDeltaX;
                        previousDeltaX = deltaX;
                        
                        let sensitivity = dragSensitivity.normal;
                        
                        // æŒ‰ä½shifté”®å¤§èŒƒå›´è°ƒæ•´
                        if (e.shiftKey) {
                            sensitivity = dragSensitivity.shift;
                        } 
                        // æŒ‰ä½ctrlé”®ç²¾ç»†è°ƒæ•´
                        else if (e.ctrlKey) {
                            sensitivity = dragSensitivity.ctrl;
                        }
                        
                        const changeIncrement = deltaDiff * sensitivity * props.step;
                        rawAccumulatedChange += changeIncrement;
                        
                        const newValue = initialValue + deltaX * sensitivity * props.step;
                        const processedValue = handleValueRange(newValue);
                        
                        // è®¡ç®—æ•´æ•°è¿›ä½ (å¾ªç¯æ¨¡å¼)
                        if (props.loop) {
                            const range = props.max - props.min + Math.pow(10, -props.precision);
                            
                            // ç›´æ¥ä»ç´¯ç§¯å˜åŒ–é‡è®¡ç®—ç»è¿‡çš„å¾ªç¯æ•°
                            const absChange = Math.abs(rawAccumulatedChange);
                            const cycles = Math.floor(absChange / range);
                            
                            // è®¡ç®—æœ‰å‘å¾ªç¯æ¬¡æ•°
                            const directedCycles = cycles * (rawAccumulatedChange >= 0 ? 1 : -1);
                            
                            // åªåœ¨å¾ªç¯æ¬¡æ•°å˜åŒ–æ—¶è§¦å‘äº‹ä»¶
                            if (directedCycles !== currentPlus.value) {
                                const increment = directedCycles - currentPlus.value;
                                
                                // åªå‘é€å®é™…å˜åŒ–çš„éƒ¨åˆ†
                                if (increment !== 0) {
                                    emit('intplus', { plus: increment });
                                }
                                
                                currentPlus.value = directedCycles;
                            }
                        }
                        
                        currentValue.value = processedValue;
                        displayValue.value = formatValue(processedValue);
                        emit('update:modelValue', processedValue);
                    };
                    
                    const handleMouseUp = () => {
                        isDragging.value = false;
                        document.removeEventListener('mousemove', handleMouseMove);
                        document.removeEventListener('mouseup', handleMouseUp);
                
                        // æ‹–æ‹½ç»“æŸåï¼Œå°†å€¼å¯¹é½åˆ°æœ€æ¥è¿‘çš„æ­¥é•¿
                        const step = props.step;
                        if (step > 0) {
                            const precision = 10; // ç”¨äºå¤„ç†æµ®ç‚¹æ•°ç²¾åº¦é—®é¢˜
                            const snappedValue = Math.round(Math.round(currentValue.value / step) * step * Math.pow(10, precision)) / Math.pow(10, precision);  
                            const processedValue = handleValueRange(snappedValue); 
                            currentValue.value = processedValue;
                            displayValue.value = formatValue(processedValue);
                        }
                        
                        // å¦‚æœæœ‰å…è®¸å€¼åˆ—è¡¨ï¼Œç¡®ä¿å€¼åœ¨åˆ—è¡¨ä¸­
                        if (props.allowedValues && props.allowedValues.length > 0) {
                            currentValue.value = handleValueRange(currentValue.value);
                            displayValue.value = formatValue(currentValue.value);
                        }
                        
                        emit('update:modelValue', currentValue.value);
                    };
                    
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                }

                return {
                    displayValue,
                    isHovering,
                    isDragging,
                    isEditing,
                    container,
                    input,
                    onBlur,
                    enableEdit,
                    handleMouseDown
                };
            }
        };

        // å®šä¹‰LockValueInputç»„ä»¶
        const LockValueInput = {
            name: 'LockValueInput',
            props: {
                modelValue: {
                    type: [Number, String],
                    default: 0
                },
                min: {
                    type: Number,
                    default: -Infinity
                },
                max: {
                    type: Number,
                    default: Infinity
                },
                step: {
                    type: Number,
                    default: 1
                },
                precision: {
                    type: Number,
                    default: 0
                },
                disabled: {
                    type: Boolean,
                    default: false
                },
                allowedValues: {
                    type: Array,
                    default: undefined
                },
                defaultLocked: {
                    type: Boolean,
                    default: false
                }
            },
            template: `
                <div class="lock-value-input">
                    <ValueInput
                        v-model="innerValue"
                        :min="min"
                        :max="max"
                        :step="step"
                        :precision="precision"
                        :disabled="disabled || locked"
                        :allowed-values="allowedValues"
                        @update:modelValue="onValueChange"
                    />
                    <button 
                        class="lock-button" 
                        :class="{ 'locked': locked }"
                        @click="toggleLock"
                    >
                        ğŸ”’
                    </button>
                </div>
            `,
            setup(props, { emit }) {
                const innerValue = ref(props.modelValue);
                const locked = ref(props.defaultLocked);
                
                watch(() => props.modelValue, (newVal) => {
                    innerValue.value = newVal;
                });
                
                watch(() => props.defaultLocked, (newVal) => {
                    locked.value = newVal;
                });
                
                function onValueChange(val) {
                    emit('update:modelValue', val);
                }
                
                function toggleLock() {
                    locked.value = !locked.value;
                    emit('update:locked', locked.value);
                }
                
                return {
                    innerValue,
                    locked,
                    onValueChange,
                    toggleLock
                };
            }
        };
        
        // å®šä¹‰MixNumberç»„ä»¶ - ä»çœŸå®ç»„ä»¶ç§»æ¤
        const MixNumber = {
            name: 'MixNumber',
            components: {
                ValueInput,
                LockValueInput
            },
            props: {
                modelValue: {
                    type: Number,
                    default: 0
                },
                precision: {
                    type: Number,
                    default: 2
                },
                step: {
                    type: Number,
                    default: 1
                },
                denominatorList: {
                    type: Array,
                    default: () => []
                },
                denominator: {
                    type: Number,
                    default: 4
                },
                denominatorLocked: {
                    type: Boolean,
                    default: false
                }
            },
            template: `
                <div class="mix-number-container">
                    <ValueInput
                        v-model="integerPart"
                        :step="1"
                        :precision="0"
                        @update:modelValue="onIntegerChange"
                    />
                    <span class="separator">+</span>
                    <ValueInput
                        v-model="numerator"
                        :min="0"
                        :max="denominatorValue - 1"
                        :step="1"
                        :precision="0"
                        :loop="true"
                        @update:modelValue="onNumeratorChange"
                        @intplus="handleNumeratorIntPlus"
                    />
                    <span class="separator">/</span>
                    <LockValueInput
                        v-model="denominatorValue"
                        :min="1"
                        :step="1"
                        :precision="0"
                        :allowed-values="denominatorListProp"
                        :default-locked="isDenominatorLocked"
                        @update:modelValue="onDenominatorChange"
                        @update:locked="onDenominatorLockChange"
                    />
                </div>
            `,
            setup(props, { emit }) {
                const integerPart = ref(0);
                const numerator = ref(0);
                const denominatorValue = ref(props.denominator);
                const isDenominatorLocked = ref(props.denominatorLocked);
                
                // åˆ›å»ºä¸€ä¸ªè®¡ç®—å±æ€§ç”¨äºæ¨¡æ¿ä¸­
                const denominatorListProp = computed(() => {
                    return props.denominatorList.length > 0 ? props.denominatorList : undefined;
                });
                
                // å¦‚æœæœ‰åˆ†æ¯åˆ—è¡¨ï¼Œåˆå§‹åŒ–æ—¶é€‰æ‹©ç¬¬ä¸€ä¸ªæœ‰æ•ˆçš„åˆ†æ¯
                watch(() => props.denominatorList, (newList) => {
                    if (newList.length > 0 && !newList.includes(denominatorValue.value)) {
                        denominatorValue.value = newList[0];
                        updatePartsFromValue(props.modelValue);
                    }
                }, { immediate: true });
                
                // ç›‘å¬åˆ†æ¯å±æ€§å˜åŒ–
                watch(() => props.denominator, (newValue) => {
                    if (newValue !== denominatorValue.value) {
                        const oldValue = internalValue.value;
                        denominatorValue.value = newValue;
                        updatePartsFromValue(oldValue);
                    }
                });
                
                // ç›‘å¬åˆ†æ¯é”å®šçŠ¶æ€å˜åŒ–
                watch(() => props.denominatorLocked, (newValue) => {
                    isDenominatorLocked.value = newValue;
                });
                
                const internalValue = computed(() => {
                    const sign = Math.sign(integerPart.value) || 1;
                    return integerPart.value + sign * (numerator.value / denominatorValue.value);
                });
                
                function updatePartsFromValue(value) {
                    const sign = Math.sign(value) || 1;
                    const absValue = Math.abs(value);
                    integerPart.value = Math.trunc(value);
                    
                    const remainder = absValue - Math.floor(absValue);
                    if (remainder > 1e-9) {
                        const newNumerator = remainder * denominatorValue.value;
                        numerator.value = Math.round(newNumerator);
                    } else {
                        numerator.value = 0;
                    }
                }
                
                watch(() => props.modelValue, (newValue) => {
                    if (Math.abs(newValue - internalValue.value) > 1e-9) {
                        updatePartsFromValue(newValue);
                    }
                }, { immediate: true });
                
                function onIntegerChange() {
                    emit('update:modelValue', internalValue.value);
                }
                
                function onNumeratorChange() {
                    emit('update:modelValue', internalValue.value);
                }
                
                function handleNumeratorIntPlus(event) {
                    if (event.plus) {
                        // æ ¹æ® plus å€¼æ›´æ–°æ•´æ•°éƒ¨åˆ†
                        const intChange = Math.floor(event.plus);
                        if (intChange !== 0) {
                            integerPart.value += intChange;
                            emit('update:modelValue', internalValue.value);
                        }
                    }
                }
                
                function onDenominatorChange(newDenominator) {
                    const oldValue = internalValue.value;
                    if (newDenominator > 0) {
                        // æ£€æŸ¥åˆ†æ¯æ˜¯å¦åœ¨å…è®¸çš„åˆ—è¡¨ä¸­
                        const denominatorList = props.denominatorList;
                        if (denominatorList.length > 0 && !denominatorList.includes(newDenominator)) {
                            // æ‰¾åˆ°æœ€æ¥è¿‘çš„æœ‰æ•ˆåˆ†æ¯å€¼
                            let closest = denominatorList[0];
                            let minDiff = Math.abs(newDenominator - closest);
                            
                            for (const denom of denominatorList) {
                                const diff = Math.abs(newDenominator - denom);
                                if (diff < minDiff) {
                                    closest = denom;
                                    minDiff = diff;
                                }
                            }
                            denominatorValue.value = closest;
                        } else {
                            denominatorValue.value = newDenominator;
                        }
                        updatePartsFromValue(oldValue);
                        emit('update:modelValue', internalValue.value);
                    }
                }
                
                function onDenominatorLockChange(locked) {
                    isDenominatorLocked.value = locked;
                    emit('update:denominatorLocked', locked);
                }
                
                return {
                    integerPart,
                    numerator,
                    denominatorValue,
                    isDenominatorLocked,
                    onIntegerChange,
                    onNumeratorChange,
                    handleNumeratorIntPlus,
                    onDenominatorChange,
                    onDenominatorLockChange,
                    denominatorListProp
                };
            }
        };

        // åˆ›å»ºå¹¶æŒ‚è½½åº”ç”¨
        const app = createApp({
            setup() {
                const testValue = ref(10);
                const mixValue = ref(2.25); // 2åˆ1/4
                const denominatorLocked = ref(false);

                function updateValue(val) {
                    testValue.value = val;
                    console.log('Updated value:', val);
                }

                function updateMixValue(val) {
                    mixValue.value = val;
                    console.log('Updated mix value:', val);
                }
                
                function updateDenominatorLocked(val) {
                    denominatorLocked.value = val;
                    console.log('Denominator locked:', val);
                }

                return {
                    testValue,
                    mixValue,
                    denominatorLocked,
                    updateValue,
                    updateMixValue,
                    updateDenominatorLocked
                };
            }
        });

        // æ³¨å†Œç»„ä»¶
        app.component('value-input', ValueInput);
        app.component('lock-value-input', LockValueInput);
        app.component('mix-number', MixNumber);

        // æŒ‚è½½åˆ°DOM
        app.mount('#app');
    </script>
</body>
</html>
